---
layout: post
title: V8垃圾回收
date: 2019-08-04
categories: test
tags: V8

---

# V8垃圾回收

垃圾收集真的是一把双刃剑。从积极的方面来说，它允许大量简化使用它的语言，因为内存不再需要由程序员明确管理。它减少了（但并未消除！）大量错误，内存泄漏，这些问题困扰着大型长期运行的应用程序。对于某些程序，它甚至可以提高性能。

另一方面，使用垃圾收集语言意味着放弃对程序中内存管理方式的大量控制，这对移动应用程序来说尤为重要。在JavaScript的情况下，您放弃对内存管理方式的*所有*控制：ECMAScript规范不会向垃圾收集器公开任何接口。Web应用程序无法测量其内存使用情况或向垃圾收集器提供任何提示。

垃圾收集语言的性能并不比没有托管内存的语言更好或更差。在C中，分配和释放对象可能成本很高，因为如果您以后需要释放对象，则堆簿记会更加复杂。对于托管内存，分配通常意味着只增加一个指针，但正如我们所看到的，当你内存不足并且垃圾收集器启动时，你必须为它付出代价。糟糕的垃圾收集系统可能会导致长时间的，不可预测的和令人尴尬的停顿，这使得交互式系统（特别是那些有动画的系统）令人沮丧地使用。引用计数经常被吹捧为垃圾收集的替代方法，但是当删除对象的大子图的最后一个引用时，这些系统可能具有相同的不可预测的暂停。

无论好坏，JavaScript都需要垃圾回收。V8的实施在去年得到了显着改善和成熟。性能非常好，暂停很短，而且开销很容易管理。

我们来挖掘吧！

## 基础

垃圾收集解决的基本问题是识别内存的死区。一旦确定，这些区域可以重新用于新的分配或释放回操作系统。如果一个物体不活（duh），它就会*死掉*。如果对象由根对象或另一个活动对象指向，则该对象是*活动的*。*根对象根目录*是有效的。它们是V8或Web浏览器直接指向的对象。例如，局部变量指向的对象是根对象，因为扫描堆栈的根。全局对象是根，因为它们始终可访问。浏览器对象（如DOM元素）也是根，但在某些情况下可能会被弱引用。

顺便说一句，你应该注意到上面的*直播*定义相当轻松。我们可以说，一个对象是*活的*，如果它会被程序再次引用。例如：

```
function f（）{
  var obj = {x：12};
  G（）; //可能包含无限循环。
  return obj.x;
}
```

不幸的是，我们无法准确地解决这个问题，因为它等同于停滞问题，这是不可判定的。所以我们做了一个方便的近似：如果一个对象可以通过某个对象的指针链到达，那么它就是实时的。其他一切都是垃圾。

## 堆组织

在我们深入研究垃圾收集器的内部工作之前，让我们先谈谈堆本身的组织方式。V8将堆分成几个不同的*空间*：

- **新空间：**大多数对象都在此处分配。新空间很小，设计为非常快速地收集垃圾，独立于其他空间。
- **旧指针空间：**包含大多数可能具有指向其他对象的指针的对象。大部分物体在新空间中生存一段时间后会移动到这里。
- **旧数据空间：**包含仅包含原始数据的对象（没有指向其他对象的指针）。字符串，盒装数字和未装箱的双打阵列在新空间中存活一段时间后会移动到这里。
- **大对象空间：**此空间包含的对象大于其他空间的大小限制。每个对象都有自己`mmap`的内存区域。垃圾收集器永远不会移动大对象。
- **代码空间：** `Code`包含JITed指令的对象在此处分配。这是唯一具有可执行内存的空间（尽管`Code`可以在大对象空间中分配s，并且这些也是可执行的）。
- **单元格空间，属性单元格空间和地图空间：**这些空间分别包含`Cell`s，`PropertyCell`s和`Map`s。这些空间中的每一个都包含大小相同的对象，并且对它们指向的对象类型有一些限制，这简化了集合。

每个空间由一组页面组成。A `Page`是一个连续的内存块，从操作系统分配`mmap`（或Windows等价物）。页面总是1 MB大小和1 MB对齐，除了大对象空间，它们可能更大。除了存储对象之外，页面还包含标题（带有各种标志和元数据）和标记位图（用于指示哪些对象是活动的）。每个页面还有一个*槽缓冲区*，分配在单独的内存中，形成一个对象列表，可以指向存储在页面上的对象。这通常被称为*记忆集*。稍后会详细介绍。

有了背景，让我们潜入垃圾收集器。

## 发现指针

区分堆上的指针和数据是垃圾收集器需要解决的第一个问题。GC需要遵循指针才能发现活动对象。大多数垃圾收集算法可以将对象从内存的一部分迁移到另一部分（以减少碎片并增加局部性），因此我们还需要能够在不干扰普通旧数据的情况下重写指针。

识别指针有三种流行的方法：

- **保守** - 这对于不受编译器支持的实现是必需的。基本上，我们将堆上的所有对齐单词视为指针。这意味着一些数据将被视为指针。因此，当一个类似于指针的整数保持对象的大子图存活时，我们可能会得到奇怪的内存泄漏。我们不能在内存中移动任何对象，因为我们可能会意外地更改我们认为是指针的数据。因此，我们没有看到压缩垃圾收集的好处（更简单的分配，更低的内存占用，更好的缓存局部性）。用于C / C ++的垃圾收集器，例如[Boehm-Demers-Weiser垃圾收集器](http://www.hpl.hp.com/personal/Hans_Boehm/gc/)采用这种方法。
- **编译器提示** - 如果我们使用静态类型语言，编译器可以告诉我们每个类中指针的偏移量。只要我们能够识别对象来自哪个类，我们就可以找到它的所有指针。Java虚拟机采用这种方法。不幸的是，这对于像JavaScript这样的动态类型语言不适用，因为对象中的任何字段都可以包含指针或数据。
- **标记指针** - 使用这种方法，我们在每个字的末尾保留一点，以指示它是指针还是数据。这种方法需要有限的编译器支持，但是它很容易实现，同时效率很高。V8采用这种方法。一些静态类型的语言，例如OCaml，也采用这种方法。

V8表示-230..230-1范围内的小整数（内部称为Smis），32位字，低位0.指针有低位01.这是因为对象总是至少4字节对齐，我们永远不会有一个指向JavaScript中对象中间的指针。堆上的大多数对象只包含一个带标记的单词列表，因此垃圾收集器可以快速扫描它们，遵循指针并忽略整数。已知某些类型的对象（如字符串）仅包含数据（无指针），因此不必标记其内容。

## 世代收藏

在绝大多数程序中，物体往往会变得年轻：大多数物体的寿命很短，而少数物体往往寿命更长。为了利用这种行为，V8将堆分为*两代*。对象在*新空间*中分配，*新空间*相当小（在1到8 MB之间，具体取决于行为启发式）。新空间中的分配非常便宜：我们只有一个分配指针，只要我们想为新对象保留空间，我们就会增加它。当分配指针到达新空间的末尾时，将触发*清除*（次要垃圾收集循环），从而快速从新空间中删除死对象。在两个小垃圾收集中存活的对象被*提升*到了旧空间。在*标记扫描*或*标记紧凑*（主要垃圾收集循环）期间，旧空间是垃圾收集的，这种情况要少得多。当我们将一定量的内存提升到旧空间时，会触发一个主要的垃圾收集周期。该阈值随着时间的推移而变化，具体取决于旧空间的大小和程序的行为。

由于清除频繁发生，它们必须非常快。Scavenge是[Cheney算法的](http://en.wikipedia.org/wiki/Cheney's_algorithm)一种实现。基本上，新空间被分为两个相等大小的半空间：空间和空间。大多数分配是在空间中进行的（尽管存在某些类型的对象，例如`Codes`总是在旧空间中分配的可执行文件）。当空间填满时，我们交换到空间和空间（所以所有对象都在空间中）。然后，我们将活动对象从空间复制出来，将它们移动到太空或将它们提升到旧空间。这些对象在进程中被压缩到空间中，因此这改善了缓存局部性，并且分配仍然快速而简单。

这是算法的伪代码版本：

```
def scavenge():
  swap(fromSpace, toSpace)
  allocationPtr = toSpace.bottom
  scanPtr = toSpace.bottom

  for i = 0..len(roots):
    root = roots[i]
    if inFromSpace(root):
      rootCopy = copyObject(&allocationPtr, root)
      setForwardingAddress(root, rootCopy)
      roots[i] = rootCopy

  while scanPtr < allocationPtr:
    obj = object at scanPtr
    scanPtr += size(obj)
    n = sizeInWords(obj)
    for i = 0..n:
      if isPointer(obj[i]) and not inOldSpace(obj[i]):
        fromNeighbor = obj[i]
        if hasForwardingAddress(fromNeighbor):
          toNeighbor = getForwardingAddress(fromNeighbor)
        else:
          toNeighbor = copyObject(&allocationPtr, fromNeighbor)
          setForwardingAddress(fromNeighbor, toNeighbor)
        obj[i] = toNeighbor

def copyObject(*allocationPtr, object):
  copy = *allocationPtr
  *allocationPtr += size(object)
  memcpy(copy, object, size(object))
  return copy
```

在这个算法中，我们始终保持两个指向空间的指针：`allocationPtr`指向我们将分配下一个对象的位置。`scanPtr`指向我们将扫描实时指针的下一个对象。下面的对象`scanPtr`已经完全处理：它们和它们的所有邻居都在空间中，并且它们的所有指针都被更新了。之间的对象`scanPtr`和`allocationPtr`已复制到对空间，但其内部指针仍然指向的对象从空间可能还没有被复制。你能想到的`scanPtr`和`allocationPtr`作为前和广度优先搜索对象的队列的后面，因为这是逻辑上发生了什么。

我们通过复制从根到达的新空间对象来初始化算法，然后我们进入主循环。在循环的每一步中，我们通过递增从队列中删除一个对象`scanPtr`，然后我们遵循它的每个内部指针。如果我们找到一个不能从空间去的指针，我们会忽略它，因为它必须指向我们没有收集的旧空间。如果我们找到一个指向空间中尚未复制的对象的指针（没有转发地址），我们通过递增将其复制到空间的末尾。`allocationPtr`（将其添加到队列中）。我们还设置了指向新副本的转发地址。转发地址存储在from-space中对象的第一个单词中，替换地图指针。垃圾收集器可以通过检查低位来区分转发地址和映射指针：映射指针被标记（低位被设置），而转发地址不被标记（低位被清除）。如果我们找到一个指向空间中已经被复制的对象的指针（具有转发地址），我们只需更新指针以指向空间复制。

当没有更多对象要处理（`scanPtr`到达`allocationPtr`）时，算法终止。此时，来自太空的内容被视为垃圾，可以被释放或重新用于其他目的。

## 写障碍：秘密成分

我在上面隐藏了一个细节：如果旧空间中的活动对象包含指向新空间中对象的唯一指针，该怎么办？我们怎么知道新物体还活着？我们当然不希望扫描所有旧空间以获取指向新空间的指针; 这将使清除非常昂贵。

为了解决这个问题，我们实际上在*存储缓冲区中*维护了一个从旧空间到新空间的指针列表。当一个对象被新分配时，我们知道没有其他对象指向它。每当指向新空间中的对象的指针被写入旧空间中的对象的字段时，我们就会在存储缓冲区中记录该字段的位置。为了实现这一点，在大多数存储之后，我们执行一些称为*写屏障*的代码，它会检测并记录这些指针。

您可能在想：每次我们将指针写入对象时执行一堆额外的指令是不是很昂贵？嗯，是。是的。这是我们为垃圾收集的便利付费的方式之一。但它并不像你想象的那么昂贵。写入并不像读取那么常见。一些垃圾收集算法（不是V8）使用读取障碍，它们需要硬件辅助才能获得可接受的低开销。还实施了许多优化以降低成本：

- 大多数执行时间都花在Crankshaft生成的优化代码上。通常，曲轴可以静态地证明物体处于新空间。对于这些对象的存储，省略写屏障。
- Crankshaft中的一个新优化是在没有对它们进行非本地引用时在堆栈上分配对象。堆栈分配对象的存储显然不需要写入障碍。
- 旧的指针相对较少，因此我们可以通过快速检测新的“旧的”旧指针来优化常见情况。每个页面在1 MB边界上对齐，因此给定一个对象地址，我们可以通过屏蔽低20位来找到它的页面。页眉有标志，指示它们是在旧空间还是新空间。因此，我们只需几条指令即可检查两个对象所在的空间。
- 一旦我们找到了旧的指针，我们只需将指针的位置记录在存储缓冲区的末尾。我们会定期（存储缓冲区填满）对存储缓冲区中的条目进行排序和反复制，并删除已被覆盖且不再指向新空间的条目。

## 标记扫描和Mark-compact

Scavenge算法非常适合快速收集和压缩少量内存，但它具有很大的空间开销，因为我们需要物理内存支持空间和空间。只要我们保持较小的新空间，这是可以接受的，但使用这种方法超过几兆字节是不切实际的。为了收集可能包含数百兆字节数据的旧空间，我们使用了两种密切相关的算法：*Mark-sweep*和*Mark-compact*。

这两种算法分两个阶段运行：*标记阶段*和*扫描阶段*或*压缩阶段*（正如您可能从名称中猜到的那样）。

在标记阶段，将发现并标记堆上的所有活动对象。每个页面都包含一个标记位图，该页面上每个可分配字一位。这是必要的，因为对象可以从任何字对齐的偏移开始。显然，这会产生一些内存开销（32位系统为3.1％，64位系统为1.6％），但所有内存管理系统都有一些开销，这是非常合理的。比特对用于表示对象的标记状态; 对象长度至少为两个字，因此这些对永远不会重叠。有三种标记状态。如果对象是*白色的*，则垃圾收集器尚未发现它。如果对象是*灰色的*它已被垃圾收集器发现，但并非所有邻居都已被处理过。如果一个对象是*黑色的*，它已被发现，并且它的所有邻居都已被完全处理。

标记算法本质上是深度优先搜索，如果您将堆视为由指针连接的对象的有向图，则这是有意义的。在标记周期的开始，标记位图是清晰的，并且所有对象都是白色的。从根可到达的对象被着色为灰色并被推到标记双端队列，这是一个单独分配的缓冲区，用于存储正在处理的对象。在每一步中，GC都会从双端队列中弹出一个对象，将其标记为黑色，将相邻的白色对象标记为灰色，然后将它们推送到双端队列。当双端队列为空并且所有发现的对象都标记为黑色时，算法终止。非常大的对象（例如长阵列）可以被分段处理以减少去除溢出的机会。如果deque确实溢出，对象仍然是灰色的，但没有被推到双端队列（因此没有发现它们的邻居）。当双端队列为空时，GC必须扫描堆中的灰色对象，将它们推回到双端队列，然后重新开始标记。

这是标记算法的伪代码版本：

```
markingDeque = []
overflow = false

def markHeap():
  for root in roots:
    mark(root)

  do:
    if overflow:
      overflow = false
      refillMarkingDeque()

    while !markingDeque.isEmpty():
      obj = markingDeque.pop()
      setMarkBits(obj, BLACK)
      for neighbor in neighbors(obj):
        mark(neighbor)
  while overflow
    

def mark(obj):
  if markBits(obj) == WHITE:
    setMarkBits(obj, GREY)
    if markingDeque.isFull():
      overflow = true
    else:
      markingDeque.push(obj)

def refillMarkingDeque():
  for each obj on heap:
    if markBits(obj) == GREY:
      markingDeque.push(obj)
      if markingDeque.isFull():
        overflow = true
        return
```

当标记算法终止时，所有活动对象都标记为黑色，所有死对象都保持白色。根据正在使用的算法，扫描阶段或压缩阶段使用此信息。

标记完成后，我们可以通过扫描或压缩来回收内存。两种算法都在页面级别工作（请记住，V8页面是1 MB连续的块，与虚拟内存页面不同）。

扫描算法扫描连续范围的死对象，将它们转换为空闲空间，并将它们添加到空闲列表中。每个页面为小区域（<256个单词），中等区域（<2048个单词），大区域（<16384个单词）和大区域（任何更大的区域）维护单独的空闲列表。扫描算法非常简单：它只是迭代页面的标记位图，寻找未标记对象的范围。清除算法主要使用自由列表将幸存对象提升到旧空间，但压缩算法也使用它们来重新定位对象。某些类型的对象只能在旧空间中分配，因此也可以使用空闲列表。

压缩算法尝试通过将对象从碎片页面（包含大量小空闲空间）迁移到其他页面上的空闲空间来减少实际内存使用量。如有必要，可以分配新页面。页面撤离后，可以将其释放回操作系统。迁移过程实际上非常复杂，因此我将在此处略过一些细节。基本上，对于疏散候选页面上的每个活动对象，空间从另一页面上的空闲列表分配。将对象复制到新分配的空间中，并在原始对象的第一个单词中保留转发地址。在撤离期间，记录撤离物体之间指针的位置。一旦疏散完成，V8迭代记录指针位置列表并更新它们以指向新副本。在标记过程中记录不同页面之间的指针位置，因此此时也会更新来自其他页面的指针。请注意，如果页面变得太“流行”，即，有太多指针要从其他页面记录到其对象，则对该页面禁用指针位置记录，并且在下一个垃圾收集周期之前不能撤离页面。

## 增量标记和懒惰扫描

正如您可能已经猜到的那样，如果将标记扫描和标记紧凑应用于具有大量实时数据的大堆，则它们可能非常耗时。当我第一次开始使用V8时，在500-1000毫秒范围内看到垃圾收集暂停并不罕见。即使对于移动设备，这显然是不可接受的。

2012年年中，谷歌推出了两项改进措施，大大减少了垃圾收集暂停：增量标记和懒惰扫描。

*增量标记*允许堆以一系列小暂停标记，每个暂停5-10毫秒（在移动设备上）。当堆达到特定阈值大小时，将开始增量标记。在激活之后，每次分配一定量的存储器时，暂停执行以执行增量标记*步骤*。与常规标记一样，增量标记基本上是深度优先搜索，并且它使用相同的白灰黑系统来对对象进行分类。

增量标记和常规标记之间的区别在于，在增量标记期间，对象图可以更改！我们需要注意的主要问题是从黑色到白色物体创建的指针。您可能还记得，垃圾收集器已经完全扫描了黑色物体，并且不再扫描它们，因此如果创建了一个黑色的白色指针，我们最终可能会将活动白色物体归类为死亡。再一次，写下障碍来解救我们。它们不仅记录了旧的指针，而且还检测到黑色的白色指针。当检测到这样的指针时，黑色物体变为灰色并被推回标记双端。当标记算法稍后弹出对象时，将重新扫描其指针，并将发现白色对象。订单保留。

一旦增量标记完成，就开始进行延迟扫描。所有对象都已标记为活动或死亡，并且堆确切地知道可以通过扫描释放多少内存。所有这些记忆并不一定要立即释放出来，延迟扫射不会真正伤害任何东西。因此，垃圾收集器不是同时扫描所有页面，而是根据需要扫描页面，直到所有页面都被扫描。此时，垃圾收集周期已完成，增量标记可以再次自由启动。

谷歌最近还加入了对并行扫地的支持。由于主执行线程不会触及死对象，因此可以通过具有最小同步量的单独线程扫描页面。平行标记也发生了一些活动，但现在似乎处于早期实验阶段。

## 结论

垃圾收集真的很复杂。我在本文中略过了很多细节，但最终还是很长。我的一位同事告诉我他认为垃圾收集器比寄存器分配器更难以工作，我完全同意。也就是说，我宁愿将内存管理的复杂性隐藏在运行时内，而不是强迫所有应用程序程序员处理它。虽然垃圾收集可能会有一些开销，偶尔会出现奇怪的行为，但它让我们不必担心会出现很多混乱的细节，因此我们可以专注于更重要的事情。