---
layout: post
title: HashMap
date: 2020-01-09
categories: test
tags: Spring Boot

---

# HashMap

HashMap是我们常用的数据结构,由**数组和链表组合构成**的数据结构

每一个节点都会保存自身的hash key value 以及下一个节点

**Java8之前是头插法**,就是说新来的值会取代原有的值,原有的值就顺推到链表中去,因为写这个代码的作者认为后来的值被查找的可能性更大一点,提升查找的效率

不同线程的插入,会形成环形链表

这个时候去取值 悲剧就出现了 ------Infinite Loop

但是,**在Java8之后,就是所用的尾部插入了**

链表有红黑树的部分,大家可以看到的代码已经多了很多if else的逻辑判断了 红黑树的引入巧妙的将原本O(n)的时间复杂度降低到了O(logn)

使用头插会改变链表上的顺序,但是使用尾插,在扩容时会保持链表元素原本的顺序,就不会出现链表成环的问题了

Java8之后 通过源码看到put/get方法都没有加同步锁 多线程情况最容易出现的就是 无法保证上一秒put的值 下一秒get的时候还是原值 所以线程安全无法保证

在这样的场景 我们一般会使用**HashTable**或者**ConcurrentHashMap** 但是因为前者的**并发度**的原因基本上没啥使用场景了 所以存在线程不安全的场景我们都使用ConcurrentHashMap

### 扩容机制

数组容量是有限的,数据多次插入,到达一定的数量就会进行扩容,也就是resize

有两个因素:

- Capacity: HashMap当前长度
- LoadFactor: 负载因子,默认值0.75F

怎么理解呢,比如,当前的容量大小为100,当你存进第76个的时候,判断发现性需要进行resize,那就进行扩容,但是HashMap的扩容也不是简单的扩大点容量这么简单的

分为两步:

- 扩容: 创建一个新的Entry空数组,长度是原数组的2倍
- ReHash: 遍历原Entry数组,把所有的Entry重新Hash到新数组

> 为什么要重新Hash呢,直接复制过去不就可以了吗

是因为长度扩大之后,Hash的规则也随之改变

````
Hash的公式--->index = HashCode( Key ) & ( Length - 1 )
````

原来长度是8,你运算出来的值是2,新的长度是16,你位运算出来的值明显不一样

> 为什么是1 << 4 直接写16不好吗

我们在创建HashMap的时候,阿里巴巴插件规范会提示我们最好赋初值,而且最好是2的幂

这样是为了位运算的方便,**位与运算比算数运算的效率高了很多**,之所以选择16,是为了服务将Key映射到index的算法

这是为了**实现均匀分布**

> 为啥我们重写equals方法的时候需要重写hashCode方法呢?

在java中,所有的对象都是继承于Object类,Object类中有两个方法equals hashCode 这两个方法都是用来比较两个对象是否相等的

在未重写equals方法我们是继承了object的equals方法,**那里的equals是比较两个对象的内存地址**,显然我们new了两个对象内存地址肯定不一样

- 对于值对象 == 是比较两个对象的值
- 对于引用对象 比较的是两个对象的地址

HashMap是通过Key的hashCode去寻找index的 那index一样就形成链表了 也就是"小明"和"明小"都可能是2 在一个链表上的

我们去get的时候 他就是根据key去hash然后计算index 找到了2 那我怎么找到具体的"小明"还是"明小"呢?

**equals** 是的 所以如果我们对equals订单进行了重写 建议一定对hashCode方法重写 以保证相同的对象返回相同的hash的值 不同的对象返回不同的hash值









